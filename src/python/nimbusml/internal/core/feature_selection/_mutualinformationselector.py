# --------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License.
# --------------------------------------------------------------------------------------------
# - Generated by tools/entrypoint_compiler.py: do not edit by hand
"""
MutualInformationSelector
"""

__all__ = ["MutualInformationSelector"]


from ...entrypoints.transforms_featureselectorbymutualinformation import \
    transforms_featureselectorbymutualinformation
from ...utils.utils import trace
from ..base_pipeline_item import (BasePipelineItem,
                                  SingleOutputSignatureWithRoles)


class MutualInformationSelector(
        BasePipelineItem,
        SingleOutputSignatureWithRoles):
    """
    Selects the top k features across all specified columns ordered by
    their mutual information with the label column.

    .. remarks::
        The mutual information of two random variables ``X`` and ``Y`` is a
        measure of the mutual dependence between the variables. Formally, the
        mutual information can be written as:

        ``I(X;Y) = E[log(p(x,y)) - log(p(x)) - log(p(y))]``

        where the expectation is taken over the joint distribution of ``X``
        and
        ``Y``. Here ``p(x,y)`` is the joint probability density function of
        ``X`` and ``Y``, ``p(x)`` and ``p(y)`` are the marginal
        probability density functions of ``X`` and ``Y`` respectively. In
        general, a higher mutual information between the dependent variable
        (or
        label) and an independent variable (or feature) means that the label
        has
        higher mutual dependence over that feature.

        The mutual information feature selection mode selects the features
        based on
        the mutual information. It keeps the top ``num_features_to_keep``
        features
        with the largest mutual information with the label.


        **Reference**

            `Wikipedia: Mutual Information
            <https://en.wikipedia.org/wiki/Mutual_information>`_


    :param slots_in_output: The maximum number of slots to preserve in output.

    :param num_bins: Numeric (R4/R8) features are binned into discrete bins
        so that the mutual information can be
        computed. This argument controls the number of bins for numerical
        values. Powers of 2
        are recommended. The default value is 256.

    :param params: Additional arguments sent to compute engine.

    .. seealso::
        :py:class:`CountSelector <nimbusml.feature_selection.CountSelector>`

    .. index:: feature, selection, mutual, information

    Example:
       .. literalinclude:: /../nimbusml/examples/MutualInformationSelector.py
              :language: python
    """

    @trace
    def __init__(
            self,
            slots_in_output=1000,
            num_bins=256,
            **params):
        BasePipelineItem.__init__(
            self, type='transform', **params)

        self.slots_in_output = slots_in_output
        self.num_bins = num_bins

    @property
    def _entrypoint(self):
        return transforms_featureselectorbymutualinformation

    @trace
    def _get_node(self, **all_args):

        input_columns = self.input
        if input_columns is None and 'input' in all_args:
            input_columns = all_args['input']
        if 'input' in all_args:
            all_args.pop('input')

        # validate input
        if input_columns is None:
            raise ValueError(
                "'None' input passed when it cannot be none.")

        if not isinstance(input_columns, list):
            raise ValueError(
                "input has to be a list of strings, instead got %s" %
                type(input_columns))

        algo_args = dict(
            column=input_columns,
            label_column_name=self._getattr_role(
                'label_column_name',
                all_args),
            slots_in_output=self.slots_in_output,
            num_bins=self.num_bins)

        all_args.update(algo_args)
        return self._entrypoint(**all_args)
